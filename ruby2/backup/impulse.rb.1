
class Frame

  attr :proto, true
  attr :slots, true

  def self.new(*args)
    result = super(*args)
    
    return Value.new(result)
  end

  def initialize(proto)
    @proto, @slots = proto, {}
  end

  def setSlot(symbol, value)
    return @slots[symbol] = value
  end

  def getSlot(symbol)
    return @slots[symbol]
  end

  def send_(selector, receiver, args, locals)
    #puts "Frame::send()"

    value = receiver.getSlot(selector)
    
    if value
      return value.eval_(receiver, args, locals)
    else
      puts "Slot not found: " + selector.to_s
    end
    
    return nil
  end

  def eval_(receiver, args, locals)
    return self
  end
  
end


class ObjectProto < Frame

  def self.instance()
    return @instance ||= ObjectProto.new()
  end
  
  def initialize()
    super(nil)
  end

end


class FunctionProto < Frame

  attr :func, true
  
  def initialize(func)
    super(ObjectProto.instance())
    
    @func = func
  end

  def eval_(receiver, args, locals)
    func.call(receiver, args, locals);
  end

end


class NumberProto < Frame

  def self.instance()
    return @instance ||= NumberProto.new()
  end

  def initialize()
    super(ObjectProto.instance())
    
    self.setSlot(:sin, FunctionProto.new(self.method(:sin)))
    self.setSlot(:pow, FunctionProto.new(self.method(:pow_)))
  end

  def sin(receiver, args, locals)
    return Value.new(Math.sin(receiver.float))
  end

  def pow_(receiver, args, locals)
    return Value.new(receiver.float ** args[0].float)
  end

end


class Value

  attr :frame, true
  attr :float, true

  def initialize(value)
    if value.is_a? Numeric
      @frame, @float = NumberProto.instance().frame, value
    else
      @frame = value
    end
  end

  def eval_(receiver, args, locals)
    #puts "Value::eval()"
    
    if @frame == NumberProto.instance().frame
      return self
    else
      return @frame.eval_(receiver, args, locals)
    end
  end

  def send_(selector, args, locals)
    return @frame.send_(selector, self, args, locals)
  end

  def setSlot(symbol, value)
    return @frame.setSlot(symbol, value)
  end
  
  def getSlot(symbol)
    return @frame.getSlot(symbol)
  end

  def inspect()
  	"#<#{self.class.name} @frame=#{@frame.class.name} @float=#{@float}>"
  end

end


class MessageProto < Frame

  attr :selector, true
  attr :args, true

  def initialize(selector, args)
    super(ObjectProto.instance())
    
    @selector, @args = selector, args
  end

  def eval_(receiver, args, locals)
    #puts "MessageProto::eval()"

    messageArgs = @args.map do |arg|
      arg.eval_(locals, [], locals)
    end

    receiver.send_(@selector, messageArgs, locals)
  end

end


class ExpressionProto < Frame

  def initialize(messages)
    super(ObjectProto.instance())
    
    @messages = messages
  end
  
  def eval_(receiver, args, locals)
    return @messages.reduce(receiver) do |receiver, value|
      value.eval_(receiver, [], locals)
    end
  end

end


class LobbyProto < Frame

  def initialize()
    super(ObjectProto.instance())
  end
  
end


lobby = LobbyProto.new()
lobby.setSlot(:x, Value.new(5))
lobby.setSlot(:y, Value.new(2))

code = [MessageProto.new(:x, []), MessageProto.new(:pow, [MessageProto.new(:y, [])])]
#code = [Value.new(10), MessageProto.new(:sin, [])]
#code = [MessageProto.new(:x, [])]

p ExpressionProto.new(code).eval_(lobby, [], lobby)

