

What is Impulse




* Simple, clean syntax with prototype inheritance
* Methods require 'return' to return a value, blocks do not





object <array> :: <collection>

  field size
  field type

  local [x, y] = self.point
  
  method map (block)
    local array = []
    
    self.each (|item|
      block [item]
    end)
    
    return array
  end

end



class BlockProto < FunctionProto

  attr :argnames, true
  attr :expressions, true
  attr :locals, true

  def initialize(argnames, expressions, locals)
    super(self.method(:eval_block))

    @argnames, @expressions, @locals = argnames, expressions, locals

    self.set_slot(:eval, FunctionProto.new(self.method(:eval_)))
  end

  def eval_block(receiver, args, locals)
    locals = LocalsProto.new(@locals)

    @argnames.each.with_index do |argname, i|
      locals.set_slot(argname, args[i])
    end

    return @expressions.reduce(locals) do |receiver, expression|
      expression.eval_(receiver, [], locals)
    end
  end

end


object <block-proto> :: <function-proto>

   field argnames = [], public: true
   field expressions,   required: true, public: true
   field locals,        required: true
   
   method init ()
      super (self.method :eval-block)
      
      self.set-slot (#eval, <function-proto>.with-block (self.method #eval))
   end
  
   method eval-block (receiver, args, locals)
      local locals = <locals-proto>.with-proto (locals)
    
      self.argnames.each.with-index (|argname, i|
         locals.set-slot (argname, value: args[i])
      end)
    
      return self.expressions.fold (|receiver, expression|
         expression.eval (receiver, [], locals)
      end, with: locals)
   end

end


object <block-proto> :: <function-proto>

   field argnames = [], reader: true
   field expressions,   required: true, reader: true
   field locals,        required: true, public: true
   
   method init ()
      super (self.method :eval-block)
      
      self.set-slot #eval, <function-proto>.with-block (self.method #eval)
   end
  
   method eval-block (receiver, args, locals)
      local locals = <locals-proto>.with-proto locals
    
      self.argnames.each.with-index |argname, i|
         locals.set-slot argname, value: args[i]
      end
    
      return self.expressions.fold |receiver, expression|
         expression.eval receiver, [], locals
      end, with: locals
   end

   method locals = (value)
      self@foo = value
   end

end

<block-proto>.create argnames: [#x, #y], expression: nil, locals: nil


object <block-proto> :: <function-proto>

   field argnames = [], reader: true
   field expressions,   required: true, reader: true
   field locals,        required: true, public: true
   
   method init
      super (self method: #eval-block)
      
      self set-slot: #eval, <function-proto> with-block: (self method: #eval)
   end
  
   method eval-block: receiver, args, locals
      local locals = <locals-proto> with-proto: locals
    
      self argnames each with-index: |argname, i|
         locals set-slot: argname, value: args[i]
      end
    
      return self expressions fold: |receiver, expression|
         expression eval: receiver, [], locals
      end, with: locals
   end

   method locals: value
      self.locals = value
   end

end

<block-proto> create: (argnames: [#x, #y], expression: nil, locals: nil)



* How to assign fields directly from constructor?
* Use parens in method calls when needed, like in math: (a * a) + (b * b)
* Reserve "=" for assigning locals only?


object <window>
extend <window>

trait <enumerable>

