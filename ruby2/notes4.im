
filter (not . even) [1..100]

[1..100] filter: not . even



actors = [1, 2, 3]

foldl1 (\x y -> x + y) [1, 2, 3]


foldl (\x y -> x + y) 0 [1, 2, 3]


foldl (\(accum, step) x -> (accum * x, step + 1)) (1, 0) [1..5]

foldl (+) ([1, 3, 3], 0) [0..10]


let actors = [1..10]
in foldl (\(a, b) x -> (map (+ 1) a, b + 1)) ([1, 2, 3], 0) [1..10]



until (\(actors, step) -> do
	actors' <- map (\actor -> advance item) actors
	return (actors', step + 1)



	(advance a, step + 1)) (1, 0) [1..5]

fold (_1 * _3, _2 + 1) [1..5]


[1..5] fold: _ * x, _ + 1, with: 1, 0



			fold ({actors: actors, step: 0}, function (accum)
			{
				actors1 = accum . actors . map (function (item)
				{
					return item . advance ();
				});

				if (accum.step < steps)
				{
					return {actors: actors1, step: accum . step + 1};
				}
			});



loop |actors, step| do
   actors.map |actor|
      item.advance
   end
end

[step..steps].fold |actors, step|
   actors.map |actor| actor.advance
end, with: actors

